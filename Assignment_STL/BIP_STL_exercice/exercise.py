import mtl

from databaseConnection import DatabaseConnection

# Exercise: STL Monitoring for a Gantry Crane Digital Twin
"""
Prerequisites:
1. Make sure that you are connected to the university of Antwerp network (either local or via VPN)
2. Tunnel the database connection over SSH:
ssh -L 5432:localhost:5432 -i ~/.ssh/certificate username@143.129.43.20
* where username is your username on the netlab server
* where certificate is the ssh private key for the netlab server
3. Make sure that the requirements.txt dependencies are installed (IDEs like pycharm will do this for you)

Learning Objectives:
1. Understand and implement safety monitoring using STL
2. Progress from basic to complex temporal properties

Background:
- A gantry crane moves containers along a rail (x-direction)
- Key measurements: position (x) and swing angle (θ). They come from the database connection
- Safe operation requires monitoring multiple properties

Worked Example - Monitoring Angular Position Bounds:
Step 1: Convert numerical signal to boolean signal
    - We need to check if |θ| ≤ 0.095 at all times
    - Create a lambda function that takes (time, value) pairs and returns (time, boolean)

Step 2: Write the STL formula
    - We want the |θ| ≤ 0.095 to hold for all time points
    - Use the G (globally) operator

Step 3: Combine in the monitoring function
    - Create data dictionary with our boolean signal
    - Apply the STL formula and check result
"""


class CraneMonitor(object):
    def __init__(self):
        # Worked Example: Angular Position Bounds
        # Step 1: Lambda function to check bounds
        self.theta_within_bounds = lambda lst: [(t, abs(entry) <= 0.095) for (t, entry) in lst]

        # Step 2: STL formula - should always be within bounds
        self.theta_bounds_check = mtl.parse('G(theta_bound)')
        # theta_bound is the key of a dictionary with the value: a list of (time,value)-pairs
        # For step 3 goto def check_theta_bounds(self, theta):

        # Now it's your turn! Complete the following exercises...
        # Part 1: Basic Safety Bounds
        # Exercise 1.1: Operation domain: Position bounds checking: Postion should never be smaller than 0.0
        # or larger than 0.45; Same as, always has to be in range [0.0, 0.45].
        # TODO: Create lambda function for position bounds [0.0, 0.45]
        self.x_within_min = lambda lst: [(t, x >= 0.0) for (t, x) in lst]
        self.x_within_max = lambda lst:  [(t, x <= 0.45) for (t, x) in lst]

        # Exercise 1.2: Write STL formula for position bounds
        # TODO: Write your first STL formula. You want that the position never exceeds
        #  for the whole future.
        self.bounds_check = mtl.parse('G(min_x & max_x)')  # Your STL formula here

        #-----------------------------------
        # Part 2: Position-Based Properties
        # Exercise 2.1: Check if crane reaches target positions
        # The target position is a parameter, based on the trajectory (generated by the control component)
        # For this you need to also get trajectory information out of the database (the function is provided)
        # TODO: Implement check for:
        # - Reaching loading position (x = 0.0 ± 0.01)
        # - Reaching unloading position (x = end_pos ± 0.04)
        self.at_loading = lambda lst, start_position: [(t, abs(x - start_position) <= 0.01) for (t, x) in lst]
        self.at_unloading = lambda lst, end_position:  [(t, abs(x - end_position) <= 0.04) for (t, x) in lst]
        # As the STL formula is dynamic (based on the time calculated by the trajectory planner),
        # We will put the formula in the check_proper_transport_sequence.

        # -----------------------------------
        # Part 3: Complex Dynamic Behavior
        # Exercise 3.1: Implement swing detection
        # TODO: Create lambda functions for:
        # - When arriving at the end of the trajectory, the swinging should end within 0.1 seconds
        # - Stable swing (|θ| ≤ 0.003)
        self.swing_stable = lambda lst: [(t, abs(entry) <= 0.003) for (t, entry) in lst]
        self.x_end_reached = lambda lst,end_pos: [(t, x == end_pos) for (t, x) in lst]

        # Exercise 3.2: Write STL formula for swing settling requirement
        # Advanced: After reaching the end position, swing should settle within 0.2s
        # and remain stable for at least 0.15s
        self.settling_check = mtl.parse('G(x_end_reached -> F[0, 0.2] (swing_stable & G[0, 0.15] swing_stable))')

        #---------------------------------------
        # Part 4: Find another property you want to check. Make sure that it is a property that is impossible to achieve
        # Write the filters, property and checker for the property
        # Self-made check 1: Check that the velocity of the crane is always below 0.4 m/s
        self.max_velocity = lambda lst: [(t, abs(v) <= 0.4) for (t, v) in lst]
        self.velocity_check = mtl.parse('G(max_velocity)')
        
        # Self-made check 2: Check that the angular velocity of the crane is always below 0.35 rad/s
        self.max_angular_velocity = lambda lst: [(t, abs(v) <= 0.45) for (t, v) in lst]
        self.angular_velocity_check = mtl.parse('G(max_angular_velocity)')
        
        # Self-made check 3: Check that the acceleration of the crane is always below 9 m/s^2
        self.max_acceleration = lambda lst: [(t, abs(a) <= 9) for (t, a) in lst]
        self.acceleration_check = mtl.parse('G(max_acceleration)')

    # Example monitoring method
    def check_theta_bounds(self, theta):
        '''
        Example monitoring method for angular position bounds
        param theta: list of (timestamp, value) pairs for angular position
        returns: bool: True if bounds are satisfied, False otherwise
        '''
        # Step 3: Create data dictionary with our boolean signal
        data = {}
        data['theta_bound'] = self.theta_within_bounds(theta)

        # Apply STL formula
        return self.theta_bounds_check(data, quantitative=False)

    def check_x_bounds(self, x):
        '''
        Example monitoring method for x position bounds
        param x: list of (timestamp, value) pairs for x position
        returns: bool: True if bounds are satisfied, False otherwise
        '''
        # Step 3: Create data dictionary with our boolean signal
        data = {}
        data['min_x'] = self.x_within_min(x)
        data['max_x'] = self.x_within_max(x)

        # Apply STL formula
        return self.bounds_check(data, quantitative=False)

    def check_proper_transport_sequence(self, x, traj_start, traj_end, max_t ):
        """

        :param x: list with pairs of (time, x(t))
        :param traj_start: start point of the trajectory
        :param traj_end: end point of the trajectory
        :param max_t: time needed to complete the trajectory
        :return: evlauation of the STL formula
        """
        # Exercise 2.2: Write STL formula for proper transport sequence
        # Hint: Use the F operator to check if positions are reached in sequence
        # The trajectory should be done within a certain timespan (trajectory_end - trajectory_start ± 0.2)
        # Because the formula is dynamic
        traj_end += 0.2
        traj_start -= 0.2
        self.transport_sequence = mtl.parse(f'G(traj_start -> F[0, {max_t}] traj_end)')  # Your STL formula here
        data = {}
        data['traj_start'] =  self.at_loading(x, traj_start)
        data['traj_end'] =  self.at_unloading(x, traj_end)
        
        return self.transport_sequence(data, quantitative=False)
        

    def check_settling(self, x, theta):
        """
        Checks the settling time property.
        :param x: list with pairs of (time, x(t))
        :param theta: list with pairs of (time, theta(t))
        :return: evaluation of the STL formula
        """
        #self.settling_check = mtl.parse('G(x_end_reached -> F[0, 0.1] swing_stable)')
        data = {}
        data['x_end_reached'] = self.x_end_reached(x, 0.45)
        data['swing_stable'] = self.swing_stable(theta)
        return self.settling_check(data, quantitative=False)

    def check_velocity(self, velocity):
        """
        Check the velocity of the crane
        :param velocity: list with pairs of (time, velocity(t))
        :return: evaluation of the STL formula
        """
        data = {}
        data['max_velocity'] = self.max_velocity(velocity)
        return self.velocity_check(data, quantitative=False)
    
    def check_angular_velocity(self, angular_velocity):
        """
        Check the angular velocity of the crane
        :param angular_velocity: list with pairs of (time, angular velocity(t))
        :return: evaluation of the STL formula
        """
        data = {}
        data['max_angular_velocity'] = self.max_angular_velocity(angular_velocity)
        return self.angular_velocity_check(data, quantitative=False)
    
    def check_acceleration(self, acceleration):
        """
        Check the acceleration of the crane
        :param acceleration: list with pairs of (time, acceleration(t))
        :return: evaluation of the STL formula
        """
        data = {}
        data['max_acceleration'] = self.max_acceleration(acceleration)
        return self.acceleration_check(data, quantitative=False)


dbc =DatabaseConnection()

measurements = dbc.get_measurement()
trajectory = dbc.get_trajectory()
cm = CraneMonitor()
# Check 1
angle_bounds_check =  cm.check_theta_bounds(measurements['angular position'])
print(f"Angle Bounds: {'✓' if angle_bounds_check else '✗'}")

# Check 2
bounds_check_x = cm.check_x_bounds(measurements['position'])
print(f"Position Bounds: {'✓' if bounds_check_x else '✗'}")

# Check 3
proper_transport = cm.check_proper_transport_sequence(measurements['position'], trajectory['position'][0][1], trajectory['position'][-1][1], trajectory['position'][-1][0]) 
print(f"Proper Transport Sequence: {'✓' if proper_transport else '✗'}")

# Check 4
settling_check = cm.check_settling(measurements['position'], measurements['angular position'])
print(f"Settling Check: {'✓' if settling_check else '✗'}")

# Check 5
velocity_check = cm.check_velocity(measurements['velocity'])
print(f"Velocity Check: {'✓' if velocity_check else '✗'}")

# Check 6
angular_velocity_check = cm.check_angular_velocity(measurements['angular velocity'])
print(f"Angular Velocity Check: {'✓' if angular_velocity_check else '✗'}")

# Check 7
acceleration_check = cm.check_acceleration(measurements['acceleration'])
print(f"Acceleration Check: {'✓' if acceleration_check else '✗'}")